<!--- vim: set ft=text: --->
# Estimating global parameters using the TdG master-slave distributed program

## Introduction

Typical analysis of a collection of sequences to estimate the distribution of selection coefficients using the TdG12 program involves:

1. Creating the sequence alignment (e.g. PRANK)
2. Estimating the tree topology (e.g. RaXML)
3. Estimating the branch lengths (e.g. PAML)
4. Estimating the distribution of _S_ using TdG.

Step 4 requires the alignment, tree with optimised branch lengths and estimates of the global parameters. The global parameters are:

- tau (rate of multiple substitutions)
- kappa (transitions-transversions bias)
- pi (nucleotide base frequencies)
- mu (branch length scaling factor)

Although estimates for each of these parameters, save tau, can be obtained from the PAML codeml program, we can also estimate them under the TdG12 model.

## Requirements

We require the tdg12.jar Java archive which can be built from source code & libraries obtained from [github](https://github.com/tamuri/tdg12) in addition to the alignment (in Phylip sequential format) and tree (in Newick format) of sequences that you're analysing.

## Estimating global parameters

Due to the sitewise nature of the model, the estimation of parameters requires significant computational resources. For this reason, we distribute the workload over many computers. The software provides a master-slave architecture: the slave component estimates the fitness of individual sites given the alignment, tree and global parameters, while the master component coordinates the one or more slaves to optimise and estimate the global parameters.

1. First, make sure that there are no host*.txt files in the tdg directory. These files are generated by the slaves and provide the IP address and port on which the slave is listening for requests.

2. Start as many slaves as you are able! It is best to start each slave with the same number of threads on similarly powered computers. This is to simplify the distribution of site analysis by the master component. Say we would like to estimate the global parameters for the PB2 alignment and tree provided in the etc/ directory. We start a slave by running:

	`java -Xmx1024m -cp dist/tdg12.jar tdg.distributed.Slave -t etc/PB2_FMutSel0.tree -s etc/PB2.co -optimruns 1 -threads 8 -useapprox -gc standard -pi 0.25,0.25,0.25,0.25 -mu 2.0 -kappa 2.0 -tau 1e-6`
    
	The options for the program are:

	* -Xmx1024m : Java option to set a large amount of memory so the slave can cache results for the repeated runs while estimating global parameters
	* -cp dist/tdg12.jar : Java classpath is the archive for the tdg12 program. This .jar includes all additional libraries required by the program.
	* tdg.distributed.Slave : full name of the slave program
	* -t, -s, -optimruns, -threads, -useapprox, -gc : these are typical parameters for tdg analysis (see tutorial for more detailed explanation). We recommend that -optimruns is set to '1' and -useapprox is set when estimating the global parameters.
	* -pi, -mu, -kappa, -tau : these are global parameters that are provided only to intialise the slaves. The values you put here are not important.


3. Once your slaves have started, you will notice some new files have been written in the tdg directory:

	$ ls host*.txt

	hostmb1209.txt

	$ cat hostmb1209.txt

	mb1209.local/192.168.2.1:59996

	These files provide the IP address and port number of each of the slaves. You should have as many host*.txt files as slaves you have started.

4. Start the master component by running:

	`java -Xmx512m -cp dist/tdg12.jar tdg.distributed.Master -s etc/PB2.co -gc standard -tau 0.01 -kappa 6.0 -pi 0.25,0.25,0.25,0.25 -mu 2.0 -convergence 1e-2 -optimise-globals`

	The options for the program are:

	* -Xmx512m : maximum memory heap size
	* -cp dist/tdg12.jar : as above
	* tdg.distributed.Master : full name of the master program
	* -s, -gc : as above
	* -tau, -kappa, -pi, -mu : the initial parameter values for the global estimate search. These should be sensible as they provide the starting values for the optimiser. You can use estimates from PAML, if you have them (see tutorial).
	* -convergence : the convergence tolerance for the global parameter optimiser. Smaller values take longer but provide more accurate estimates. 1e-2 or 1e-3 is usually okay.
	* -optimise-global : tells the tdg.distributed.Master program to actually optimise the global parameters. If you don't provide this option, the program will just estimate the sitewise fitness values (using the slaves), sum the log-likelihoods and provide the result for the parameter values you provided.
	
5. Sit back and wait. The master program will run 5 iterations of the search to ensure convergence. Imagine we ran the slave and master programs with the options above. The final output is:

	Results of optimisation iterations:

	Result{1. lnL =	-73647.3007252314, point =	0.008268538915210365	7.337604298591016	0.24687113563427712	0.20541809744069706	0.3353076913140285	2.939640477291896}

	Result{2. lnL =	-73356.4901854075, point =	0.011970529062261037	7.219119067957712	0.2394285823907314	0.19508476592668167	0.3620668013222946	3.1115960073776785}

	Result{3. lnL =	-73344.0751320604, point =	0.01256667619350562	7.2304942368534295	0.23793169165458178	0.19421388449032642	0.3675406345987173	3.1274625438454766}

	Result{4. lnL =	-73343.7402801198, point =	0.012902933074550248	7.225246322381873	0.23754388688219638	0.19427812063184227	0.3678298291331865	3.1297949932069}
	
	Result{5. lnL =	-73343.72693470365, point =	0.013146864766105538	7.217345081265038	0.2371535555509682	0.19431105469804832	0.3683120562650635	3.134573186600915}

	FINISHED!
	
	The order of parameters in the 'point' array is: tau, kappa, pi (T), pi (C), pi (G) and mu.


6. If you believe that the program hasn't converged, you can repeatedly run the master with different start parameters.



